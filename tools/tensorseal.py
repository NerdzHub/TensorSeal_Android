#!/usr/bin/env python3
import os
import argparse
import secrets
from Crypto.Cipher import AES
from Crypto.Util import Counter

# --- CONFIGURATION ---
HEADER_TEMPLATE = """#ifndef SECRET_KEY_H
#define SECRET_KEY_H

#include <stdint.h>

// AUTO-GENERATED BY TENSORSEAL. DO NOT EDIT MANUALLY.
// This function constructs the key on the stack to avoid static analysis.
inline void get_runtime_key(uint8_t* key) {{
    // Key Logic: Stack String Construction
    {body}
}}

#endif // SECRET_KEY_H
"""

def generate_cpp_stack_logic(key_bytes):
    """
    Generates C++ code to construct the key byte-by-byte on the stack.
    This prevents the key from appearing as a contiguous string in the binary.
    """
    code_lines = []

    # We define volatile variables for the bytes
    code_lines.append(f"    // Hex: {key_bytes.hex().upper()}")

    for i, byte in enumerate(key_bytes):
        # We use volatile to prevent compiler optimization
        # We also cast to uint8_t explicitly
        code_lines.append(f"    volatile uint8_t k{i} = 0x{byte:02X};")

    code_lines.append("")

    for i in range(len(key_bytes)):
        code_lines.append(f"    key[{i}] = k{i};")

    return "\n".join(code_lines)

def encrypt_model(input_path, output_path, key):
    """
    Encrypts the model using AES-128-CTR with a random IV.
    Format: [IV (16 bytes)] + [Encrypted Body]
    """
    # 1. Read Input
    with open(input_path, 'rb') as f:
        plaintext = f.read()

    print(f"üì¶ Loaded Model: {input_path} ({len(plaintext)} bytes)")

    # 2. Setup Crypto
    iv = secrets.token_bytes(16)
    ctr = Counter.new(128, initial_value=int.from_bytes(iv, byteorder='big'))
    cipher = AES.new(key, AES.MODE_CTR, counter=ctr)

    # 3. Encrypt
    ciphertext = cipher.encrypt(plaintext)

    # 4. Write Output (IV + Ciphertext)
    with open(output_path, 'wb') as f:
        f.write(iv)
        f.write(ciphertext)

    print(f"üîí Encrypted to: {output_path}")
    print(f"üîë Key used:     {key.hex().upper()}")

def generate_header(output_header_path, key):
    """
    Writes the C++ header file with the obfuscated key logic.
    """
    logic_body = generate_cpp_stack_logic(key)
    content = HEADER_TEMPLATE.format(body=logic_body)

    with open(output_header_path, 'w') as f:
        f.write(content)

    print(f"üìù Generated C++ Header: {output_header_path}")

def main():
    parser = argparse.ArgumentParser(description="TensorSeal: Secure Model Packer")

    parser.add_argument("--input", "-i", required=True, help="Path to input .tflite model")
    parser.add_argument("--output", "-o", required=True, help="Path to output .lock file (Assets)")
    parser.add_argument("--header", "-d", required=True, help="Path to output SecretKey.h (C++ Source)")
    parser.add_argument("--key", "-k", help="Optional hex key (32 chars). If empty, generates random.")

    args = parser.parse_args()

    # 1. Determine Key
    if args.key:
        try:
            key = bytes.fromhex(args.key)
            if len(key) != 16:
                raise ValueError("Key must be 16 bytes (32 hex chars) for AES-128")
        except ValueError as e:
            print(f"‚ùå Error: {e}")
            return
    else:
        print("üé≤ Generating new random 128-bit key...")
        key = secrets.token_bytes(16)

    # 2. Encrypt
    encrypt_model(args.input, args.output, key)

    # 3. Generate Header
    generate_header(args.header, key)

    print("\n‚úÖ DONE. Clean and Rebuild your Android project now.")

if __name__ == "__main__":
    main()